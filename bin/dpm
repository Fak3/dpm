#!/usr/bin/env node

var path = require('path')
  , dpinit = require('datapackage-init')
  , util = require('util')
  , isUrl = require('is-url')
  , request = require('request')
  , fs = require('fs')
  , Dpm = require('../lib/index')
  , optimist = require('optimist')
  , read = require('read')
  , async = require('async')
  , rimraf = require('rimraf')
  , validate = require('npm-user-validate')
  , semver = require('semver')
  , split = require('split')
  , querystring = require('querystring')
  , tree = require('../lib/tree')
  , readdirpSync = require('fs-readdir-recursive')
  , os = require('os')
  , colors = require('colors');

var argv = optimist
  .usage(
    [
      'Usage:',
      '',
      '  $0 COMMAND ...',
      '',
      'where command is one of:',
      '',
      '  init <path>      create a datapackage.json file in directory <path>',
      '  validate <path>  validate datapackage.json file in directory <path>',
      '  install  <url>   install a data packages into the current project along with its dependencies',
      '  help <command>   Get help on command'
    ].join(os.EOL)
  )
  .alias('f', 'force').describe('f', 'just do it')
  .alias('s', 'save').describe('s', 'data packages will appear in your dataDependencies')
  .alias('c', 'cache').describe('c', 'store the resources content on the disk in a data/ directory')
  .alias('h', 'help').describe('h', 'print usage')
  .alias('v', 'version').describe('v', 'print version number')
  .argv;

if(argv.h){
  console.log(optimist.help());
  process.exit(0);
}

if(argv.v){
  console.log(require('../package.json').version);
  process.exit(0);
}

var conf = require('rc')('dpm', {}, process.cwd());
var dpm = new Dpm(conf)

if(argv._[0] !== 'cat'){
  dpm.on('log', console.log);
}

if (argv._[0] === 'init') {
  dpinit.init(dpm.root, function(err, dpkg) {
    var path_ = path.join(dpm.root, 'datapackage.json');
    console.log('datapackage.json written to ' + path_);
  });
} else if (argv._[0] === 'validate') {
  if (argv._.length > 1) {
    dpm.validate(argv._[1]);
  } else {
    dpm.validate(); 
  }
} else if(argv._[0] === 'install'){

  (function(){
    var dpkgIds = argv._.slice(1);
    var dpkg;
    if(!dpkgIds.length || argv.save){ //get deps for a package.json
      try{
        dpkg = JSON.parse(fs.readFileSync(path.join(dpm.root, 'package.json')));
      } catch(e){
        _fail(new Error('could not load '+ path.join(dpm.root, 'package.json')));
      }
    }

    if(!dpkgIds.length){
      dpm.resolveDeps(dpkg.dataDependencies, function(err, dpkgIds){
        if(err) _fail(err);
        next(dpkgIds);
      });
    } else {
      next(dpkgIds);
    }

    function next(dpkgIds){
      dpm.install(dpkgIds, {cache: argv.cache, force: argv.force}, function(err, dpkgs){
        if(err) _fail(err);
        if(argv.save){
          dpkg.dataDependencies = dpkg.dataDependencies || {};
          dpkgs.forEach(function(x){
            dpkg.dataDependencies[x.name] =  x.version;
          });
          fs.writeFileSync(path.join(dpm.root, 'package.json'), JSON.stringify(dpkg, null, 2));
        }
        console.log(tree.deps(dpkgs));
      });
    };

  })();

} else if (argv._[0] === 'help'){

  var cmd = argv._[1];
  if(cmd && ['init', 'cat', 'clone', 'get', 'install'].indexOf(cmd) !== -1){
    console.log(fs.readFileSync(path.join(path.dirname(__dirname), 'doc', 'command-' + cmd + '.md'), 'utf8'));
  } else {
    console.log(optimist.help());
  }

} else {

  _fail(new Error('invalid command'));

};

function _fail(err){
  if(err){
    console.error('dpm'.grey +  ' ERR! '.red + err.message + (('code' in err) ? ' (' + err.code + ')': ''));
    process.exit(1);
  }
};
